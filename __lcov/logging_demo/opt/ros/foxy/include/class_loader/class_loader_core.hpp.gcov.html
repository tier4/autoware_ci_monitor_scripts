<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - lcov.total.filtered - /opt/ros/foxy/include/class_loader/class_loader_core.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">opt/ros/foxy/include/class_loader</a> - class_loader_core.hpp<span style="font-size: 80%;"> (source / <a href="class_loader_core.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">lcov.total.filtered</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryHi">94.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-05-13 06:35:35</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<a name="2"><span class="lineNum">       2 </span>            :  * Software License Agreement (BSD License)</a>
<a name="3"><span class="lineNum">       3 </span>            :  *</a>
<a name="4"><span class="lineNum">       4 </span>            :  * Copyright (c) 2012, Willow Garage, Inc.</a>
<a name="5"><span class="lineNum">       5 </span>            :  * All rights reserved.</a>
<a name="6"><span class="lineNum">       6 </span>            :  *</a>
<a name="7"><span class="lineNum">       7 </span>            :  * Redistribution and use in source and binary forms, with or without</a>
<a name="8"><span class="lineNum">       8 </span>            :  * modification, are permitted provided that the following conditions are met:</a>
<a name="9"><span class="lineNum">       9 </span>            :  *</a>
<a name="10"><span class="lineNum">      10 </span>            :  *     * Redistributions of source code must retain the above copyright</a>
<a name="11"><span class="lineNum">      11 </span>            :  *       notice, this list of conditions and the following disclaimer.</a>
<a name="12"><span class="lineNum">      12 </span>            :  *     * Redistributions in binary form must reproduce the above copyright</a>
<a name="13"><span class="lineNum">      13 </span>            :  *       notice, this list of conditions and the following disclaimer in the</a>
<a name="14"><span class="lineNum">      14 </span>            :  *       documentation and/or other materials provided with the distribution.</a>
<a name="15"><span class="lineNum">      15 </span>            :  *     * Neither the name of the copyright holders nor the names of its</a>
<a name="16"><span class="lineNum">      16 </span>            :  *       contributors may be used to endorse or promote products derived from</a>
<a name="17"><span class="lineNum">      17 </span>            :  *       this software without specific prior written permission.</a>
<a name="18"><span class="lineNum">      18 </span>            :  *</a>
<a name="19"><span class="lineNum">      19 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="21"><span class="lineNum">      21 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="22"><span class="lineNum">      22 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</a>
<a name="23"><span class="lineNum">      23 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="24"><span class="lineNum">      24 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="25"><span class="lineNum">      25 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="26"><span class="lineNum">      26 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="27"><span class="lineNum">      27 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="28"><span class="lineNum">      28 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="29"><span class="lineNum">      29 </span>            :  * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="30"><span class="lineNum">      30 </span>            :  */</a>
<a name="31"><span class="lineNum">      31 </span>            : </a>
<a name="32"><span class="lineNum">      32 </span>            : #ifndef CLASS_LOADER__CLASS_LOADER_CORE_HPP_</a>
<a name="33"><span class="lineNum">      33 </span>            : #define CLASS_LOADER__CLASS_LOADER_CORE_HPP_</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : #include &lt;cstddef&gt;</a>
<a name="36"><span class="lineNum">      36 </span>            : #include &lt;cstdio&gt;</a>
<a name="37"><span class="lineNum">      37 </span>            : #include &lt;map&gt;</a>
<a name="38"><span class="lineNum">      38 </span>            : #include &lt;memory&gt;</a>
<a name="39"><span class="lineNum">      39 </span>            : #include &lt;mutex&gt;</a>
<a name="40"><span class="lineNum">      40 </span>            : #include &lt;string&gt;</a>
<a name="41"><span class="lineNum">      41 </span>            : #include &lt;typeinfo&gt;</a>
<a name="42"><span class="lineNum">      42 </span>            : #include &lt;utility&gt;</a>
<a name="43"><span class="lineNum">      43 </span>            : #include &lt;vector&gt;</a>
<a name="44"><span class="lineNum">      44 </span>            : </a>
<a name="45"><span class="lineNum">      45 </span>            : // TODO(mikaelarguedas) remove this once console_bridge complies with this</a>
<a name="46"><span class="lineNum">      46 </span>            : // see https://github.com/ros/console_bridge/issues/55</a>
<a name="47"><span class="lineNum">      47 </span>            : #ifdef __clang__</a>
<a name="48"><span class="lineNum">      48 </span>            : # pragma clang diagnostic push</a>
<a name="49"><span class="lineNum">      49 </span>            : # pragma clang diagnostic ignored &quot;-Wgnu-zero-variadic-macro-arguments&quot;</a>
<a name="50"><span class="lineNum">      50 </span>            : #endif</a>
<a name="51"><span class="lineNum">      51 </span>            : #include &quot;console_bridge/console.h&quot;</a>
<a name="52"><span class="lineNum">      52 </span>            : #ifdef __clang__</a>
<a name="53"><span class="lineNum">      53 </span>            : # pragma clang diagnostic pop</a>
<a name="54"><span class="lineNum">      54 </span>            : #endif</a>
<a name="55"><span class="lineNum">      55 </span>            : </a>
<a name="56"><span class="lineNum">      56 </span>            : #include &quot;class_loader/exceptions.hpp&quot;</a>
<a name="57"><span class="lineNum">      57 </span>            : #include &quot;class_loader/meta_object.hpp&quot;</a>
<a name="58"><span class="lineNum">      58 </span>            : #include &quot;class_loader/visibility_control.hpp&quot;</a>
<a name="59"><span class="lineNum">      59 </span>            : </a>
<a name="60"><span class="lineNum">      60 </span>            : #include &quot;rcpputils/shared_library.hpp&quot;</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            : /**</a>
<a name="63"><span class="lineNum">      63 </span>            :  * @note This header file is the internal implementation of the plugin system which is exposed via the ClassLoader class</a>
<a name="64"><span class="lineNum">      64 </span>            :  */</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span>            : namespace class_loader</a>
<a name="67"><span class="lineNum">      67 </span>            : {</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            : class ClassLoader;  // Forward declaration</a>
<a name="70"><span class="lineNum">      70 </span>            : </a>
<a name="71"><span class="lineNum">      71 </span>            : namespace impl</a>
<a name="72"><span class="lineNum">      72 </span>            : {</a>
<a name="73"><span class="lineNum">      73 </span>            : </a>
<a name="74"><span class="lineNum">      74 </span>            : // Typedefs</a>
<a name="75"><span class="lineNum">      75 </span>            : typedef std::string LibraryPath;</a>
<a name="76"><span class="lineNum">      76 </span>            : typedef std::string ClassName;</a>
<a name="77"><span class="lineNum">      77 </span>            : typedef std::string BaseClassName;</a>
<a name="78"><span class="lineNum">      78 </span>            : typedef std::map&lt;ClassName, impl::AbstractMetaObjectBase *&gt; FactoryMap;</a>
<a name="79"><span class="lineNum">      79 </span>            : typedef std::map&lt;BaseClassName, FactoryMap&gt; BaseToFactoryMapMap;</a>
<a name="80"><span class="lineNum">      80 </span>            : typedef std::pair&lt;LibraryPath, std::shared_ptr&lt;rcpputils::SharedLibrary&gt;&gt; LibraryPair;</a>
<a name="81"><span class="lineNum">      81 </span>            : typedef std::vector&lt;LibraryPair&gt; LibraryVector;</a>
<a name="82"><span class="lineNum">      82 </span>            : typedef std::vector&lt;AbstractMetaObjectBase *&gt; MetaObjectVector;</a>
<a name="83"><span class="lineNum">      83 </span>            : </a>
<a name="84"><span class="lineNum">      84 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="85"><span class="lineNum">      85 </span>            : void printDebugInfoToScreen();</a>
<a name="86"><span class="lineNum">      86 </span>            : </a>
<a name="87"><span class="lineNum">      87 </span>            : // Global storage</a>
<a name="88"><span class="lineNum">      88 </span>            : </a>
<a name="89"><span class="lineNum">      89 </span>            : /**</a>
<a name="90"><span class="lineNum">      90 </span>            :  * @brief Gets a handle to a global data structure that holds a map of base class names (Base class describes plugin interface) to a FactoryMap which holds the factories for the various different concrete classes that can be instantiated. Note that the Base class is NOT THE LITERAL CLASSNAME, but rather the result of typeid(Base).name() which sometimes is the literal class name (as on Windows) but is often in mangled form (as on Linux).</a>
<a name="91"><span class="lineNum">      91 </span>            :  * @return A reference to the global base to factory map</a>
<a name="92"><span class="lineNum">      92 </span>            :  */</a>
<a name="93"><span class="lineNum">      93 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="94"><span class="lineNum">      94 </span>            : BaseToFactoryMapMap &amp; getGlobalPluginBaseToFactoryMapMap();</a>
<a name="95"><span class="lineNum">      95 </span>            : </a>
<a name="96"><span class="lineNum">      96 </span>            : /**</a>
<a name="97"><span class="lineNum">      97 </span>            :  * @brief Gets a handle to a list of open libraries in the form of LibraryPairs which encode the library path+name and the handle to the underlying shared library</a>
<a name="98"><span class="lineNum">      98 </span>            :  * @return A reference to the global vector that tracks loaded libraries</a>
<a name="99"><span class="lineNum">      99 </span>            :  */</a>
<a name="100"><span class="lineNum">     100 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="101"><span class="lineNum">     101 </span>            : LibraryVector &amp; getLoadedLibraryVector();</a>
<a name="102"><span class="lineNum">     102 </span>            : </a>
<a name="103"><span class="lineNum">     103 </span>            : /**</a>
<a name="104"><span class="lineNum">     104 </span>            :  * @brief When a library is being loaded, in order for factories to know which library they are being associated with, they use this function to query which library is being loaded.</a>
<a name="105"><span class="lineNum">     105 </span>            :  * @return The currently set loading library name as a string</a>
<a name="106"><span class="lineNum">     106 </span>            :  */</a>
<a name="107"><span class="lineNum">     107 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="108"><span class="lineNum">     108 </span>            : std::string getCurrentlyLoadingLibraryName();</a>
<a name="109"><span class="lineNum">     109 </span>            : </a>
<a name="110"><span class="lineNum">     110 </span>            : /**</a>
<a name="111"><span class="lineNum">     111 </span>            :  * @brief When a library is being loaded, in order for factories to know which library they are being associated with, this function is called to set the name of the library currently being loaded.</a>
<a name="112"><span class="lineNum">     112 </span>            :  * @param library_name - The name of library that is being loaded currently</a>
<a name="113"><span class="lineNum">     113 </span>            :  */</a>
<a name="114"><span class="lineNum">     114 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="115"><span class="lineNum">     115 </span>            : void setCurrentlyLoadingLibraryName(const std::string &amp; library_name);</a>
<a name="116"><span class="lineNum">     116 </span>            : </a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span>            : /**</a>
<a name="119"><span class="lineNum">     119 </span>            :  * @brief Gets the ClassLoader currently in scope which used when a library is being loaded.</a>
<a name="120"><span class="lineNum">     120 </span>            :  * @return A pointer to the currently active ClassLoader.</a>
<a name="121"><span class="lineNum">     121 </span>            :  */</a>
<a name="122"><span class="lineNum">     122 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="123"><span class="lineNum">     123 </span>            : ClassLoader * getCurrentlyActiveClassLoader();</a>
<a name="124"><span class="lineNum">     124 </span>            : </a>
<a name="125"><span class="lineNum">     125 </span>            : /**</a>
<a name="126"><span class="lineNum">     126 </span>            :  * @brief Sets the ClassLoader currently in scope which used when a library is being loaded.</a>
<a name="127"><span class="lineNum">     127 </span>            :  * @param loader - pointer to the currently active ClassLoader.</a>
<a name="128"><span class="lineNum">     128 </span>            :  */</a>
<a name="129"><span class="lineNum">     129 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="130"><span class="lineNum">     130 </span>            : void setCurrentlyActiveClassLoader(ClassLoader * loader);</a>
<a name="131"><span class="lineNum">     131 </span>            : </a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<a name="133"><span class="lineNum">     133 </span>            : /**</a>
<a name="134"><span class="lineNum">     134 </span>            :  * @brief This function extracts a reference to the FactoryMap for appropriate base class out of the global plugin base to factory map. This function should be used by functions in this namespace that need to access the various factories so as to make sure the right key is generated to index into the global map.</a>
<a name="135"><span class="lineNum">     135 </span>            :  * @return A reference to the FactoryMap contained within the global Base-to-FactoryMap map.</a>
<a name="136"><span class="lineNum">     136 </span>            :  */</a>
<a name="137"><span class="lineNum">     137 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="138"><span class="lineNum">     138 </span>            : FactoryMap &amp; getFactoryMapForBaseClass(const std::string &amp; typeid_base_class_name);</a>
<a name="139"><span class="lineNum">     139 </span>            : </a>
<a name="140"><span class="lineNum">     140 </span>            : /**</a>
<a name="141"><span class="lineNum">     141 </span>            :  * @brief Same as above but uses a type parameter instead of string for more safety if info is available.</a>
<a name="142"><span class="lineNum">     142 </span>            :  * @return A reference to the FactoryMap contained within the global Base-to-FactoryMap map.</a>
<a name="143"><span class="lineNum">     143 </span>            :  */</a>
<a name="144"><span class="lineNum">     144 </span>            : template&lt;typename Base&gt;</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">          2 : FactoryMap &amp; getFactoryMapForBaseClass()</span></a>
<a name="146"><span class="lineNum">     146 </span>            : {</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineCov">          4 :   return getFactoryMapForBaseClass(typeid(Base).name());</span></a>
<a name="148"><span class="lineNum">     148 </span>            : }</a>
<a name="149"><span class="lineNum">     149 </span>            : </a>
<a name="150"><span class="lineNum">     150 </span>            : /**</a>
<a name="151"><span class="lineNum">     151 </span>            :  * @brief To provide thread safety, all exposed plugin functions can only be run serially by multiple threads. This is implemented by using critical sections enforced by a single mutex which is locked and released with the following two functions</a>
<a name="152"><span class="lineNum">     152 </span>            :  * @return A reference to the global mutex</a>
<a name="153"><span class="lineNum">     153 </span>            :  */</a>
<a name="154"><span class="lineNum">     154 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="155"><span class="lineNum">     155 </span>            : std::recursive_mutex &amp; getLoadedLibraryVectorMutex();</a>
<a name="156"><span class="lineNum">     156 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="157"><span class="lineNum">     157 </span>            : std::recursive_mutex &amp; getPluginBaseToFactoryMapMapMutex();</a>
<a name="158"><span class="lineNum">     158 </span>            : </a>
<a name="159"><span class="lineNum">     159 </span>            : /**</a>
<a name="160"><span class="lineNum">     160 </span>            :  * @brief Indicates if a library containing more than just plugins has been opened by the running process</a>
<a name="161"><span class="lineNum">     161 </span>            :  * @return True if a non-pure plugin library has been opened, otherwise false</a>
<a name="162"><span class="lineNum">     162 </span>            :  */</a>
<a name="163"><span class="lineNum">     163 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="164"><span class="lineNum">     164 </span>            : bool hasANonPurePluginLibraryBeenOpened();</a>
<a name="165"><span class="lineNum">     165 </span>            : </a>
<a name="166"><span class="lineNum">     166 </span>            : /**</a>
<a name="167"><span class="lineNum">     167 </span>            :  * @brief Sets a flag indicating if a library containing more than just plugins has been opened by the running process</a>
<a name="168"><span class="lineNum">     168 </span>            :  * @param hasIt - The flag</a>
<a name="169"><span class="lineNum">     169 </span>            :  */</a>
<a name="170"><span class="lineNum">     170 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="171"><span class="lineNum">     171 </span>            : void hasANonPurePluginLibraryBeenOpened(bool hasIt);</a>
<a name="172"><span class="lineNum">     172 </span>            : </a>
<a name="173"><span class="lineNum">     173 </span>            : // Plugin Functions</a>
<a name="174"><span class="lineNum">     174 </span>            : </a>
<a name="175"><span class="lineNum">     175 </span>            : /**</a>
<a name="176"><span class="lineNum">     176 </span>            :  * @brief This function is called by the CLASS_LOADER_REGISTER_CLASS macro in plugin_register_macro.h to register factories.</a>
<a name="177"><span class="lineNum">     177 </span>            :  * Classes that use that macro will cause this function to be invoked when the library is loaded. The function will create a MetaObject (i.e. factory) for the corresponding Derived class and insert it into the appropriate FactoryMap in the global Base-to-FactoryMap map. Note that the passed class_name is the literal class name and not the mangled version.</a>
<a name="178"><span class="lineNum">     178 </span>            :  * @param Derived - parameteric type indicating concrete type of plugin</a>
<a name="179"><span class="lineNum">     179 </span>            :  * @param Base - parameteric type indicating base type of plugin</a>
<a name="180"><span class="lineNum">     180 </span>            :  * @param class_name - the literal name of the class being registered (NOT MANGLED)</a>
<a name="181"><span class="lineNum">     181 </span>            :  */</a>
<a name="182"><span class="lineNum">     182 </span>            : template&lt;typename Derived, typename Base&gt;</a>
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">          2 : void registerPlugin(const std::string &amp; class_name, const std::string &amp; base_class_name)</span></a>
<a name="184"><span class="lineNum">     184 </span>            : {</a>
<a name="185"><span class="lineNum">     185 </span>            :   // Note: This function will be automatically invoked when a dlopen() call</a>
<a name="186"><span class="lineNum">     186 </span>            :   // opens a library. Normally it will happen within the scope of loadLibrary(),</a>
<a name="187"><span class="lineNum">     187 </span>            :   // but that may not be guaranteed.</a>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">          2 :   CONSOLE_BRIDGE_logDebug(</span></a>
<a name="189"><span class="lineNum">     189 </span>            :     &quot;class_loader.impl: &quot;</a>
<a name="190"><span class="lineNum">     190 </span>            :     &quot;Registering plugin factory for class = %s, ClassLoader* = %p and library name %s.&quot;,</a>
<a name="191"><span class="lineNum">     191 </span>            :     class_name.c_str(), getCurrentlyActiveClassLoader(),</a>
<a name="192"><span class="lineNum">     192 </span>            :     getCurrentlyLoadingLibraryName().c_str());</a>
<a name="193"><span class="lineNum">     193 </span>            : </a>
<a name="194"><span class="lineNum">     194 </span><span class="lineCov">          2 :   if (nullptr == getCurrentlyActiveClassLoader()) {</span></a>
<a name="195"><span class="lineNum">     195 </span><span class="lineCov">          2 :     CONSOLE_BRIDGE_logDebug(</span></a>
<a name="196"><span class="lineNum">     196 </span>            :       &quot;%s&quot;,</a>
<a name="197"><span class="lineNum">     197 </span>            :       &quot;class_loader.impl: ALERT!!! &quot;</a>
<a name="198"><span class="lineNum">     198 </span>            :       &quot;A library containing plugins has been opened through a means other than through the &quot;</a>
<a name="199"><span class="lineNum">     199 </span>            :       &quot;class_loader or pluginlib package. &quot;</a>
<a name="200"><span class="lineNum">     200 </span>            :       &quot;This can happen if you build plugin libraries that contain more than just plugins &quot;</a>
<a name="201"><span class="lineNum">     201 </span>            :       &quot;(i.e. normal code your app links against). &quot;</a>
<a name="202"><span class="lineNum">     202 </span>            :       &quot;This inherently will trigger a dlopen() prior to main() and cause problems as class_loader &quot;</a>
<a name="203"><span class="lineNum">     203 </span>            :       &quot;is not aware of plugin factories that autoregister under the hood. &quot;</a>
<a name="204"><span class="lineNum">     204 </span>            :       &quot;The class_loader package can compensate, but you may run into namespace collision problems &quot;</a>
<a name="205"><span class="lineNum">     205 </span>            :       &quot;(e.g. if you have the same plugin class in two different libraries and you load them both &quot;</a>
<a name="206"><span class="lineNum">     206 </span>            :       &quot;at the same time). &quot;</a>
<a name="207"><span class="lineNum">     207 </span>            :       &quot;The biggest problem is that library can now no longer be safely unloaded as the &quot;</a>
<a name="208"><span class="lineNum">     208 </span>            :       &quot;ClassLoader does not know when non-plugin code is still in use. &quot;</a>
<a name="209"><span class="lineNum">     209 </span>            :       &quot;In fact, no ClassLoader instance in your application will be unable to unload any library &quot;</a>
<a name="210"><span class="lineNum">     210 </span>            :       &quot;once a non-pure one has been opened. &quot;</a>
<a name="211"><span class="lineNum">     211 </span>            :       &quot;Please refactor your code to isolate plugins into their own libraries.&quot;);</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">          2 :     hasANonPurePluginLibraryBeenOpened(true);</span></a>
<a name="213"><span class="lineNum">     213 </span>            :   }</a>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<a name="215"><span class="lineNum">     215 </span>            :   // Create factory</a>
<a name="216"><span class="lineNum">     216 </span>            :   impl::AbstractMetaObject&lt;Base&gt; * new_factory =</a>
<a name="217"><span class="lineNum">     217 </span><span class="lineCov">          2 :     new impl::MetaObject&lt;Derived, Base&gt;(class_name, base_class_name);</span></a>
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">          2 :   new_factory-&gt;addOwningClassLoader(getCurrentlyActiveClassLoader());</span></a>
<a name="219"><span class="lineNum">     219 </span><span class="lineCov">          2 :   new_factory-&gt;setAssociatedLibraryPath(getCurrentlyLoadingLibraryName());</span></a>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<a name="221"><span class="lineNum">     221 </span>            : </a>
<a name="222"><span class="lineNum">     222 </span>            :   // Add it to global factory map map</a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">          2 :   getPluginBaseToFactoryMapMapMutex().lock();</span></a>
<a name="224"><span class="lineNum">     224 </span><span class="lineCov">          2 :   FactoryMap &amp; factoryMap = getFactoryMapForBaseClass&lt;Base&gt;();</span></a>
<a name="225"><span class="lineNum">     225 </span><span class="lineCov">          2 :   if (factoryMap.find(class_name) != factoryMap.end()) {</span></a>
<a name="226"><span class="lineNum">     226 </span><span class="lineNoCov">          0 :     CONSOLE_BRIDGE_logWarn(</span></a>
<a name="227"><span class="lineNum">     227 </span>            :       &quot;class_loader.impl: SEVERE WARNING!!! &quot;</a>
<a name="228"><span class="lineNum">     228 </span>            :       &quot;A namespace collision has occured with plugin factory for class %s. &quot;</a>
<a name="229"><span class="lineNum">     229 </span>            :       &quot;New factory will OVERWRITE existing one. &quot;</a>
<a name="230"><span class="lineNum">     230 </span>            :       &quot;This situation occurs when libraries containing plugins are directly linked against an &quot;</a>
<a name="231"><span class="lineNum">     231 </span>            :       &quot;executable (the one running right now generating this message). &quot;</a>
<a name="232"><span class="lineNum">     232 </span>            :       &quot;Please separate plugins out into their own library or just don't link against the library &quot;</a>
<a name="233"><span class="lineNum">     233 </span>            :       &quot;and use either class_loader::ClassLoader/MultiLibraryClassLoader to open.&quot;,</a>
<a name="234"><span class="lineNum">     234 </span>            :       class_name.c_str());</a>
<a name="235"><span class="lineNum">     235 </span>            :   }</a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">          2 :   factoryMap[class_name] = new_factory;</span></a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">          2 :   getPluginBaseToFactoryMapMapMutex().unlock();</span></a>
<a name="238"><span class="lineNum">     238 </span>            : </a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">          2 :   CONSOLE_BRIDGE_logDebug(</span></a>
<a name="240"><span class="lineNum">     240 </span>            :     &quot;class_loader.impl: &quot;</a>
<a name="241"><span class="lineNum">     241 </span>            :     &quot;Registration of %s complete (Metaobject Address = %p)&quot;,</a>
<a name="242"><span class="lineNum">     242 </span>            :     class_name.c_str(), reinterpret_cast&lt;void *&gt;(new_factory));</a>
<a name="243"><span class="lineNum">     243 </span><span class="lineCov">          2 : }</span></a>
<a name="244"><span class="lineNum">     244 </span>            : </a>
<a name="245"><span class="lineNum">     245 </span>            : /**</a>
<a name="246"><span class="lineNum">     246 </span>            :  * @brief This function creates an instance of a plugin class given the derived name of the class and returns a pointer of the Base class type.</a>
<a name="247"><span class="lineNum">     247 </span>            :  * @param derived_class_name - The name of the derived class (unmangled)</a>
<a name="248"><span class="lineNum">     248 </span>            :  * @param loader - The ClassLoader whose scope we are within</a>
<a name="249"><span class="lineNum">     249 </span>            :  * @return A pointer to newly created plugin, note caller is responsible for object destruction</a>
<a name="250"><span class="lineNum">     250 </span>            :  */</a>
<a name="251"><span class="lineNum">     251 </span>            : template&lt;typename Base&gt;</a>
<a name="252"><span class="lineNum">     252 </span>            : Base * createInstance(const std::string &amp; derived_class_name, ClassLoader * loader)</a>
<a name="253"><span class="lineNum">     253 </span>            : {</a>
<a name="254"><span class="lineNum">     254 </span>            :   AbstractMetaObject&lt;Base&gt; * factory = nullptr;</a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span>            :   getPluginBaseToFactoryMapMapMutex().lock();</a>
<a name="257"><span class="lineNum">     257 </span>            :   FactoryMap &amp; factoryMap = getFactoryMapForBaseClass&lt;Base&gt;();</a>
<a name="258"><span class="lineNum">     258 </span>            :   if (factoryMap.find(derived_class_name) != factoryMap.end()) {</a>
<a name="259"><span class="lineNum">     259 </span>            :     factory = dynamic_cast&lt;impl::AbstractMetaObject&lt;Base&gt; *&gt;(factoryMap[derived_class_name]);</a>
<a name="260"><span class="lineNum">     260 </span>            :   } else {</a>
<a name="261"><span class="lineNum">     261 </span>            :     CONSOLE_BRIDGE_logError(</a>
<a name="262"><span class="lineNum">     262 </span>            :       &quot;class_loader.impl: No metaobject exists for class type %s.&quot;, derived_class_name.c_str());</a>
<a name="263"><span class="lineNum">     263 </span>            :   }</a>
<a name="264"><span class="lineNum">     264 </span>            :   getPluginBaseToFactoryMapMapMutex().unlock();</a>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<a name="266"><span class="lineNum">     266 </span>            :   Base * obj = nullptr;</a>
<a name="267"><span class="lineNum">     267 </span>            :   if (factory != nullptr &amp;&amp; factory-&gt;isOwnedBy(loader)) {</a>
<a name="268"><span class="lineNum">     268 </span>            :     obj = factory-&gt;create();</a>
<a name="269"><span class="lineNum">     269 </span>            :   }</a>
<a name="270"><span class="lineNum">     270 </span>            : </a>
<a name="271"><span class="lineNum">     271 </span>            :   if (nullptr == obj) {  // Was never created</a>
<a name="272"><span class="lineNum">     272 </span>            :     if (factory &amp;&amp; factory-&gt;isOwnedBy(nullptr)) {</a>
<a name="273"><span class="lineNum">     273 </span>            :       CONSOLE_BRIDGE_logDebug(</a>
<a name="274"><span class="lineNum">     274 </span>            :         &quot;%s&quot;,</a>
<a name="275"><span class="lineNum">     275 </span>            :         &quot;class_loader.impl: ALERT!!! &quot;</a>
<a name="276"><span class="lineNum">     276 </span>            :         &quot;A metaobject (i.e. factory) exists for desired class, but has no owner. &quot;</a>
<a name="277"><span class="lineNum">     277 </span>            :         &quot;This implies that the library containing the class was dlopen()ed by means other than &quot;</a>
<a name="278"><span class="lineNum">     278 </span>            :         &quot;through the class_loader interface. &quot;</a>
<a name="279"><span class="lineNum">     279 </span>            :         &quot;This can happen if you build plugin libraries that contain more than just plugins &quot;</a>
<a name="280"><span class="lineNum">     280 </span>            :         &quot;(i.e. normal code your app links against) -- that intrinsically will trigger a dlopen() &quot;</a>
<a name="281"><span class="lineNum">     281 </span>            :         &quot;prior to main(). &quot;</a>
<a name="282"><span class="lineNum">     282 </span>            :         &quot;You should isolate your plugins into their own library, otherwise it will not be &quot;</a>
<a name="283"><span class="lineNum">     283 </span>            :         &quot;possible to shutdown the library!&quot;);</a>
<a name="284"><span class="lineNum">     284 </span>            : </a>
<a name="285"><span class="lineNum">     285 </span>            :       obj = factory-&gt;create();</a>
<a name="286"><span class="lineNum">     286 </span>            :     } else {</a>
<a name="287"><span class="lineNum">     287 </span>            :       throw class_loader::CreateClassException(</a>
<a name="288"><span class="lineNum">     288 </span>            :               &quot;Could not create instance of type &quot; + derived_class_name);</a>
<a name="289"><span class="lineNum">     289 </span>            :     }</a>
<a name="290"><span class="lineNum">     290 </span>            :   }</a>
<a name="291"><span class="lineNum">     291 </span>            : </a>
<a name="292"><span class="lineNum">     292 </span>            :   CONSOLE_BRIDGE_logDebug(</a>
<a name="293"><span class="lineNum">     293 </span>            :     &quot;class_loader.impl: Created instance of type %s and object pointer = %p&quot;,</a>
<a name="294"><span class="lineNum">     294 </span>            :     (typeid(obj).name()), obj);</a>
<a name="295"><span class="lineNum">     295 </span>            : </a>
<a name="296"><span class="lineNum">     296 </span>            :   return obj;</a>
<a name="297"><span class="lineNum">     297 </span>            : }</a>
<a name="298"><span class="lineNum">     298 </span>            : </a>
<a name="299"><span class="lineNum">     299 </span>            : /**</a>
<a name="300"><span class="lineNum">     300 </span>            :  * @brief This function returns all the available class_loader in the plugin system that are derived from Base and within scope of the passed ClassLoader.</a>
<a name="301"><span class="lineNum">     301 </span>            :  * @param loader - The pointer to the ClassLoader whose scope we are within,</a>
<a name="302"><span class="lineNum">     302 </span>            :  * @return A vector of strings where each string is a plugin we can create</a>
<a name="303"><span class="lineNum">     303 </span>            :  */</a>
<a name="304"><span class="lineNum">     304 </span>            : template&lt;typename Base&gt;</a>
<a name="305"><span class="lineNum">     305 </span>            : std::vector&lt;std::string&gt; getAvailableClasses(const ClassLoader * loader)</a>
<a name="306"><span class="lineNum">     306 </span>            : {</a>
<a name="307"><span class="lineNum">     307 </span>            :   std::lock_guard&lt;std::recursive_mutex&gt; lock(getPluginBaseToFactoryMapMapMutex());</a>
<a name="308"><span class="lineNum">     308 </span>            : </a>
<a name="309"><span class="lineNum">     309 </span>            :   FactoryMap &amp; factory_map = getFactoryMapForBaseClass&lt;Base&gt;();</a>
<a name="310"><span class="lineNum">     310 </span>            :   std::vector&lt;std::string&gt; classes;</a>
<a name="311"><span class="lineNum">     311 </span>            :   std::vector&lt;std::string&gt; classes_with_no_owner;</a>
<a name="312"><span class="lineNum">     312 </span>            : </a>
<a name="313"><span class="lineNum">     313 </span>            :   for (auto &amp; it : factory_map) {</a>
<a name="314"><span class="lineNum">     314 </span>            :     AbstractMetaObjectBase * factory = it.second;</a>
<a name="315"><span class="lineNum">     315 </span>            :     if (factory-&gt;isOwnedBy(loader)) {</a>
<a name="316"><span class="lineNum">     316 </span>            :       classes.push_back(it.first);</a>
<a name="317"><span class="lineNum">     317 </span>            :     } else if (factory-&gt;isOwnedBy(nullptr)) {</a>
<a name="318"><span class="lineNum">     318 </span>            :       classes_with_no_owner.push_back(it.first);</a>
<a name="319"><span class="lineNum">     319 </span>            :     }</a>
<a name="320"><span class="lineNum">     320 </span>            :   }</a>
<a name="321"><span class="lineNum">     321 </span>            : </a>
<a name="322"><span class="lineNum">     322 </span>            :   // Added classes not associated with a class loader (Which can happen through</a>
<a name="323"><span class="lineNum">     323 </span>            :   // an unexpected dlopen() to the library)</a>
<a name="324"><span class="lineNum">     324 </span>            :   classes.insert(classes.end(), classes_with_no_owner.begin(), classes_with_no_owner.end());</a>
<a name="325"><span class="lineNum">     325 </span>            :   return classes;</a>
<a name="326"><span class="lineNum">     326 </span>            : }</a>
<a name="327"><span class="lineNum">     327 </span>            : </a>
<a name="328"><span class="lineNum">     328 </span>            : /**</a>
<a name="329"><span class="lineNum">     329 </span>            :  * @brief This function returns the names of all libraries in use by a given class loader.</a>
<a name="330"><span class="lineNum">     330 </span>            :  * @param loader - The ClassLoader whose scope we are within</a>
<a name="331"><span class="lineNum">     331 </span>            :  * @return A vector of strings where each string is the path+name of each library that are within a ClassLoader's visible scope</a>
<a name="332"><span class="lineNum">     332 </span>            :  */</a>
<a name="333"><span class="lineNum">     333 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="334"><span class="lineNum">     334 </span>            : std::vector&lt;std::string&gt; getAllLibrariesUsedByClassLoader(const ClassLoader * loader);</a>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<a name="336"><span class="lineNum">     336 </span>            : /**</a>
<a name="337"><span class="lineNum">     337 </span>            :  * @brief Indicates if passed library loaded within scope of a ClassLoader. The library maybe loaded in memory, but to the class loader it may not be.</a>
<a name="338"><span class="lineNum">     338 </span>            :  * @param library_path - The name of the library we wish to check is open</a>
<a name="339"><span class="lineNum">     339 </span>            :  * @param loader - The pointer to the ClassLoader whose scope we are within</a>
<a name="340"><span class="lineNum">     340 </span>            :  * @return true if the library is loaded within loader's scope, else false</a>
<a name="341"><span class="lineNum">     341 </span>            :  */</a>
<a name="342"><span class="lineNum">     342 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="343"><span class="lineNum">     343 </span>            : bool isLibraryLoaded(const std::string &amp; library_path, const ClassLoader * loader);</a>
<a name="344"><span class="lineNum">     344 </span>            : </a>
<a name="345"><span class="lineNum">     345 </span>            : /**</a>
<a name="346"><span class="lineNum">     346 </span>            :  * @brief Indicates if passed library has been loaded by ANY ClassLoader</a>
<a name="347"><span class="lineNum">     347 </span>            :  * @param library_path - The name of the library we wish to check is open</a>
<a name="348"><span class="lineNum">     348 </span>            :  * @return true if the library is loaded in memory, otherwise false</a>
<a name="349"><span class="lineNum">     349 </span>            :  */</a>
<a name="350"><span class="lineNum">     350 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="351"><span class="lineNum">     351 </span>            : bool isLibraryLoadedByAnybody(const std::string &amp; library_path);</a>
<a name="352"><span class="lineNum">     352 </span>            : </a>
<a name="353"><span class="lineNum">     353 </span>            : /**</a>
<a name="354"><span class="lineNum">     354 </span>            :  * @brief Loads a library into memory if it has not already been done so. Attempting to load an already loaded library has no effect.</a>
<a name="355"><span class="lineNum">     355 </span>            :  * @param library_path - The name of the library to open</a>
<a name="356"><span class="lineNum">     356 </span>            :  * @param loader - The pointer to the ClassLoader whose scope we are within</a>
<a name="357"><span class="lineNum">     357 </span>            :  */</a>
<a name="358"><span class="lineNum">     358 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="359"><span class="lineNum">     359 </span>            : void loadLibrary(const std::string &amp; library_path, ClassLoader * loader);</a>
<a name="360"><span class="lineNum">     360 </span>            : </a>
<a name="361"><span class="lineNum">     361 </span>            : /**</a>
<a name="362"><span class="lineNum">     362 </span>            :  * @brief Unloads a library if it loaded in memory and cleans up its corresponding class factories. If it is not loaded, the function has no effect</a>
<a name="363"><span class="lineNum">     363 </span>            :  * @param library_path - The name of the library to open</a>
<a name="364"><span class="lineNum">     364 </span>            :  * @param loader - The pointer to the ClassLoader whose scope we are within</a>
<a name="365"><span class="lineNum">     365 </span>            :  */</a>
<a name="366"><span class="lineNum">     366 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="367"><span class="lineNum">     367 </span>            : void unloadLibrary(const std::string &amp; library_path, ClassLoader * loader);</a>
<a name="368"><span class="lineNum">     368 </span>            : </a>
<a name="369"><span class="lineNum">     369 </span>            : }  // namespace impl</a>
<a name="370"><span class="lineNum">     370 </span>            : }  // namespace class_loader</a>
<a name="371"><span class="lineNum">     371 </span>            : </a>
<a name="372"><span class="lineNum">     372 </span>            : #endif  // CLASS_LOADER__CLASS_LOADER_CORE_HPP_</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
