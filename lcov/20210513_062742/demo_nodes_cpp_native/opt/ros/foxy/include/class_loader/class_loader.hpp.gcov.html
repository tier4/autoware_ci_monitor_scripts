<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - lcov.total.filtered - /opt/ros/foxy/include/class_loader/class_loader.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">opt/ros/foxy/include/class_loader</a> - class_loader.hpp<span style="font-size: 80%;"> (source / <a href="class_loader.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">lcov.total.filtered</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">20</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntryLo">74.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-05-13 06:32:14</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntry">3</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<a name="2"><span class="lineNum">       2 </span>            :  * Software License Agreement (BSD License)</a>
<a name="3"><span class="lineNum">       3 </span>            :  *</a>
<a name="4"><span class="lineNum">       4 </span>            :  * Copyright (c) 2012, Willow Garage, Inc.</a>
<a name="5"><span class="lineNum">       5 </span>            :  * All rights reserved.</a>
<a name="6"><span class="lineNum">       6 </span>            :  *</a>
<a name="7"><span class="lineNum">       7 </span>            :  * Redistribution and use in source and binary forms, with or without</a>
<a name="8"><span class="lineNum">       8 </span>            :  * modification, are permitted provided that the following conditions are met:</a>
<a name="9"><span class="lineNum">       9 </span>            :  *</a>
<a name="10"><span class="lineNum">      10 </span>            :  *     * Redistributions of source code must retain the above copyright</a>
<a name="11"><span class="lineNum">      11 </span>            :  *       notice, this list of conditions and the following disclaimer.</a>
<a name="12"><span class="lineNum">      12 </span>            :  *     * Redistributions in binary form must reproduce the above copyright</a>
<a name="13"><span class="lineNum">      13 </span>            :  *       notice, this list of conditions and the following disclaimer in the</a>
<a name="14"><span class="lineNum">      14 </span>            :  *       documentation and/or other materials provided with the distribution.</a>
<a name="15"><span class="lineNum">      15 </span>            :  *     * Neither the name of the copyright holders nor the names of its</a>
<a name="16"><span class="lineNum">      16 </span>            :  *       contributors may be used to endorse or promote products derived from</a>
<a name="17"><span class="lineNum">      17 </span>            :  *       this software without specific prior written permission.</a>
<a name="18"><span class="lineNum">      18 </span>            :  *</a>
<a name="19"><span class="lineNum">      19 </span>            :  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</a>
<a name="20"><span class="lineNum">      20 </span>            :  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="21"><span class="lineNum">      21 </span>            :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="22"><span class="lineNum">      22 </span>            :  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</a>
<a name="23"><span class="lineNum">      23 </span>            :  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</a>
<a name="24"><span class="lineNum">      24 </span>            :  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</a>
<a name="25"><span class="lineNum">      25 </span>            :  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</a>
<a name="26"><span class="lineNum">      26 </span>            :  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</a>
<a name="27"><span class="lineNum">      27 </span>            :  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</a>
<a name="28"><span class="lineNum">      28 </span>            :  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</a>
<a name="29"><span class="lineNum">      29 </span>            :  * POSSIBILITY OF SUCH DAMAGE.</a>
<a name="30"><span class="lineNum">      30 </span>            :  */</a>
<a name="31"><span class="lineNum">      31 </span>            : </a>
<a name="32"><span class="lineNum">      32 </span>            : #ifndef CLASS_LOADER__CLASS_LOADER_HPP_</a>
<a name="33"><span class="lineNum">      33 </span>            : #define CLASS_LOADER__CLASS_LOADER_HPP_</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            : #include &lt;algorithm&gt;</a>
<a name="36"><span class="lineNum">      36 </span>            : #include &lt;cassert&gt;</a>
<a name="37"><span class="lineNum">      37 </span>            : #include &lt;cstddef&gt;</a>
<a name="38"><span class="lineNum">      38 </span>            : #include &lt;functional&gt;</a>
<a name="39"><span class="lineNum">      39 </span>            : #include &lt;memory&gt;</a>
<a name="40"><span class="lineNum">      40 </span>            : #include &lt;mutex&gt;</a>
<a name="41"><span class="lineNum">      41 </span>            : #include &lt;string&gt;</a>
<a name="42"><span class="lineNum">      42 </span>            : #include &lt;vector&gt;</a>
<a name="43"><span class="lineNum">      43 </span>            : </a>
<a name="44"><span class="lineNum">      44 </span>            : // TODO(mikaelarguedas) remove this once console_bridge complies with this</a>
<a name="45"><span class="lineNum">      45 </span>            : // see https://github.com/ros/console_bridge/issues/55</a>
<a name="46"><span class="lineNum">      46 </span>            : #ifdef __clang__</a>
<a name="47"><span class="lineNum">      47 </span>            : # pragma clang diagnostic push</a>
<a name="48"><span class="lineNum">      48 </span>            : # pragma clang diagnostic ignored &quot;-Wgnu-zero-variadic-macro-arguments&quot;</a>
<a name="49"><span class="lineNum">      49 </span>            : #endif</a>
<a name="50"><span class="lineNum">      50 </span>            : #include &quot;console_bridge/console.h&quot;</a>
<a name="51"><span class="lineNum">      51 </span>            : #ifdef __clang__</a>
<a name="52"><span class="lineNum">      52 </span>            : # pragma clang diagnostic pop</a>
<a name="53"><span class="lineNum">      53 </span>            : #endif</a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            : #include &quot;class_loader/class_loader_core.hpp&quot;</a>
<a name="56"><span class="lineNum">      56 </span>            : #include &quot;class_loader/register_macro.hpp&quot;</a>
<a name="57"><span class="lineNum">      57 </span>            : #include &quot;class_loader/visibility_control.hpp&quot;</a>
<a name="58"><span class="lineNum">      58 </span>            : </a>
<a name="59"><span class="lineNum">      59 </span>            : namespace class_loader</a>
<a name="60"><span class="lineNum">      60 </span>            : {</a>
<a name="61"><span class="lineNum">      61 </span>            : </a>
<a name="62"><span class="lineNum">      62 </span>            : /// Returns the default library prefix for the native os</a>
<a name="63"><span class="lineNum">      63 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="64"><span class="lineNum">      64 </span>            : std::string systemLibraryPrefix();</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span>            : /// Returns runtime library extension for native os</a>
<a name="67"><span class="lineNum">      67 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="68"><span class="lineNum">      68 </span>            : std::string systemLibrarySuffix();</a>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<a name="70"><span class="lineNum">      70 </span>            : /// Returns a platform specific version of a basic library name</a>
<a name="71"><span class="lineNum">      71 </span>            : /**</a>
<a name="72"><span class="lineNum">      72 </span>            :  * On *nix platforms the library name is prefixed with `lib`.</a>
<a name="73"><span class="lineNum">      73 </span>            :  * On all platforms the output of class_loader::systemLibrarySuffix() is appended.</a>
<a name="74"><span class="lineNum">      74 </span>            :  */</a>
<a name="75"><span class="lineNum">      75 </span>            : CLASS_LOADER_PUBLIC</a>
<a name="76"><span class="lineNum">      76 </span>            : std::string systemLibraryFormat(const std::string &amp; library_name);</a>
<a name="77"><span class="lineNum">      77 </span>            : </a>
<a name="78"><span class="lineNum">      78 </span>            : /**</a>
<a name="79"><span class="lineNum">      79 </span>            :  * @class ClassLoader</a>
<a name="80"><span class="lineNum">      80 </span>            :  * @brief This class allows loading and unloading of dynamically linked libraries which contain class definitions from which objects can be created/destroyed during runtime (i.e. class_loader). Libraries loaded by a ClassLoader are only accessible within scope of that ClassLoader object.</a>
<a name="81"><span class="lineNum">      81 </span>            :  */</a>
<a name="82"><span class="lineNum">      82 </span>            : class ClassLoader</a>
<a name="83"><span class="lineNum">      83 </span>            : {</a>
<a name="84"><span class="lineNum">      84 </span>            : public:</a>
<a name="85"><span class="lineNum">      85 </span>            :   template&lt;typename Base&gt;</a>
<a name="86"><span class="lineNum">      86 </span>            :   using DeleterType = std::function&lt;void (Base *)&gt;;</a>
<a name="87"><span class="lineNum">      87 </span>            : </a>
<a name="88"><span class="lineNum">      88 </span>            :   template&lt;typename Base&gt;</a>
<a name="89"><span class="lineNum">      89 </span>            :   using UniquePtr = std::unique_ptr&lt;Base, DeleterType&lt;Base&gt;&gt;;</a>
<a name="90"><span class="lineNum">      90 </span>            : </a>
<a name="91"><span class="lineNum">      91 </span>            :   /**</a>
<a name="92"><span class="lineNum">      92 </span>            :    * @brief  Constructor for ClassLoader</a>
<a name="93"><span class="lineNum">      93 </span>            :    * @param library_path - The path of the runtime library to load</a>
<a name="94"><span class="lineNum">      94 </span>            :    * @param ondemand_load_unload - Indicates if on-demand (lazy) unloading/loading of libraries occurs as plugins are created/destroyed</a>
<a name="95"><span class="lineNum">      95 </span>            :    */</a>
<a name="96"><span class="lineNum">      96 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="97"><span class="lineNum">      97 </span>            :   explicit ClassLoader(const std::string &amp; library_path, bool ondemand_load_unload = false);</a>
<a name="98"><span class="lineNum">      98 </span>            : </a>
<a name="99"><span class="lineNum">      99 </span>            :   /**</a>
<a name="100"><span class="lineNum">     100 </span>            :    * @brief  Destructor for ClassLoader. All libraries opened by this ClassLoader are unloaded automatically.</a>
<a name="101"><span class="lineNum">     101 </span>            :    */</a>
<a name="102"><span class="lineNum">     102 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="103"><span class="lineNum">     103 </span>            :   virtual ~ClassLoader();</a>
<a name="104"><span class="lineNum">     104 </span>            : </a>
<a name="105"><span class="lineNum">     105 </span>            :   /**</a>
<a name="106"><span class="lineNum">     106 </span>            :    * @brief  Indicates which classes (i.e. class_loader) that can be loaded by this object</a>
<a name="107"><span class="lineNum">     107 </span>            :    * @return vector of strings indicating names of instantiable classes derived from &lt;Base&gt;</a>
<a name="108"><span class="lineNum">     108 </span>            :    */</a>
<a name="109"><span class="lineNum">     109 </span>            :   template&lt;class Base&gt;</a>
<a name="110"><span class="lineNum">     110 </span>            :   std::vector&lt;std::string&gt; getAvailableClasses() const</a>
<a name="111"><span class="lineNum">     111 </span>            :   {</a>
<a name="112"><span class="lineNum">     112 </span><span class="lineCov">          1 :     return class_loader::impl::getAvailableClasses&lt;Base&gt;(this);</span></a>
<a name="113"><span class="lineNum">     113 </span>            :   }</a>
<a name="114"><span class="lineNum">     114 </span>            : </a>
<a name="115"><span class="lineNum">     115 </span>            :   /**</a>
<a name="116"><span class="lineNum">     116 </span>            :    * @brief  Generates an instance of loadable classes (i.e. class_loader).</a>
<a name="117"><span class="lineNum">     117 </span>            :    *</a>
<a name="118"><span class="lineNum">     118 </span>            :    * It is not necessary for the user to call loadLibrary() as it will be invoked automatically</a>
<a name="119"><span class="lineNum">     119 </span>            :    * if the library is not yet loaded (which typically happens when in &quot;On Demand Load/Unload&quot; mode).</a>
<a name="120"><span class="lineNum">     120 </span>            :    *</a>
<a name="121"><span class="lineNum">     121 </span>            :    * @param  derived_class_name The name of the class we want to create (@see getAvailableClasses())</a>
<a name="122"><span class="lineNum">     122 </span>            :    * @return A std::shared_ptr&lt;Base&gt; to newly created plugin object</a>
<a name="123"><span class="lineNum">     123 </span>            :    */</a>
<a name="124"><span class="lineNum">     124 </span>            :   template&lt;class Base&gt;</a>
<a name="125"><span class="lineNum">     125 </span><span class="lineCov">          1 :   std::shared_ptr&lt;Base&gt; createInstance(const std::string &amp; derived_class_name)</span></a>
<a name="126"><span class="lineNum">     126 </span>            :   {</a>
<a name="127"><span class="lineNum">     127 </span>            :     return std::shared_ptr&lt;Base&gt;(</a>
<a name="128"><span class="lineNum">     128 </span>            :       createRawInstance&lt;Base&gt;(derived_class_name, true),</a>
<a name="129"><span class="lineNum">     129 </span>            :       std::bind(&amp;ClassLoader::onPluginDeletion&lt;Base&gt;, this, std::placeholders::_1)</a>
<a name="130"><span class="lineNum">     130 </span><span class="lineCov">          1 :     );</span></a>
<a name="131"><span class="lineNum">     131 </span>            :   }</a>
<a name="132"><span class="lineNum">     132 </span>            : </a>
<a name="133"><span class="lineNum">     133 </span>            :   /// Generates an instance of loadable classes (i.e. class_loader).</a>
<a name="134"><span class="lineNum">     134 </span>            :   /**</a>
<a name="135"><span class="lineNum">     135 </span>            :    * It is not necessary for the user to call loadLibrary() as it will be</a>
<a name="136"><span class="lineNum">     136 </span>            :    * invoked automatically if the library is not yet loaded (which typically</a>
<a name="137"><span class="lineNum">     137 </span>            :    * happens when in &quot;On Demand Load/Unload&quot; mode).</a>
<a name="138"><span class="lineNum">     138 </span>            :    *</a>
<a name="139"><span class="lineNum">     139 </span>            :    * If you release the wrapped pointer you must manually call the original</a>
<a name="140"><span class="lineNum">     140 </span>            :    * deleter when you want to destroy the released pointer.</a>
<a name="141"><span class="lineNum">     141 </span>            :    *</a>
<a name="142"><span class="lineNum">     142 </span>            :    * @param derived_class_name</a>
<a name="143"><span class="lineNum">     143 </span>            :    *   The name of the class we want to create (@see getAvailableClasses()).</a>
<a name="144"><span class="lineNum">     144 </span>            :    * @return A std::unique_ptr&lt;Base&gt; to newly created plugin object.</a>
<a name="145"><span class="lineNum">     145 </span>            :    */</a>
<a name="146"><span class="lineNum">     146 </span>            :   template&lt;class Base&gt;</a>
<a name="147"><span class="lineNum">     147 </span>            :   UniquePtr&lt;Base&gt; createUniqueInstance(const std::string &amp; derived_class_name)</a>
<a name="148"><span class="lineNum">     148 </span>            :   {</a>
<a name="149"><span class="lineNum">     149 </span>            :     Base * raw = createRawInstance&lt;Base&gt;(derived_class_name, true);</a>
<a name="150"><span class="lineNum">     150 </span>            :     return std::unique_ptr&lt;Base, DeleterType&lt;Base&gt;&gt;(</a>
<a name="151"><span class="lineNum">     151 </span>            :       raw,</a>
<a name="152"><span class="lineNum">     152 </span>            :       std::bind(&amp;ClassLoader::onPluginDeletion&lt;Base&gt;, this, std::placeholders::_1)</a>
<a name="153"><span class="lineNum">     153 </span>            :     );</a>
<a name="154"><span class="lineNum">     154 </span>            :   }</a>
<a name="155"><span class="lineNum">     155 </span>            : </a>
<a name="156"><span class="lineNum">     156 </span>            :   /// Generates an instance of loadable classes (i.e. class_loader).</a>
<a name="157"><span class="lineNum">     157 </span>            :   /**</a>
<a name="158"><span class="lineNum">     158 </span>            :    * It is not necessary for the user to call loadLibrary() as it will be</a>
<a name="159"><span class="lineNum">     159 </span>            :    * invoked automatically if the library is not yet loaded (which typically</a>
<a name="160"><span class="lineNum">     160 </span>            :    * happens when in &quot;On Demand Load/Unload&quot; mode).</a>
<a name="161"><span class="lineNum">     161 </span>            :    *</a>
<a name="162"><span class="lineNum">     162 </span>            :    * Creating an unmanaged instance disables dynamically unloading libraries when</a>
<a name="163"><span class="lineNum">     163 </span>            :    * managed pointers go out of scope for all class loaders in this process.</a>
<a name="164"><span class="lineNum">     164 </span>            :    *</a>
<a name="165"><span class="lineNum">     165 </span>            :    * @param derived_class_name</a>
<a name="166"><span class="lineNum">     166 </span>            :    *   The name of the class we want to create (@see getAvailableClasses()).</a>
<a name="167"><span class="lineNum">     167 </span>            :    * @return An unmanaged (i.e. not a shared_ptr) Base* to newly created plugin object.</a>
<a name="168"><span class="lineNum">     168 </span>            :    */</a>
<a name="169"><span class="lineNum">     169 </span>            :   template&lt;class Base&gt;</a>
<a name="170"><span class="lineNum">     170 </span>            :   Base * createUnmanagedInstance(const std::string &amp; derived_class_name)</a>
<a name="171"><span class="lineNum">     171 </span>            :   {</a>
<a name="172"><span class="lineNum">     172 </span>            :     return createRawInstance&lt;Base&gt;(derived_class_name, false);</a>
<a name="173"><span class="lineNum">     173 </span>            :   }</a>
<a name="174"><span class="lineNum">     174 </span>            : </a>
<a name="175"><span class="lineNum">     175 </span>            :   /**</a>
<a name="176"><span class="lineNum">     176 </span>            :    * @brief Indicates if a plugin class is available</a>
<a name="177"><span class="lineNum">     177 </span>            :    * @param Base - polymorphic type indicating base class</a>
<a name="178"><span class="lineNum">     178 </span>            :    * @param class_name - the name of the plugin class</a>
<a name="179"><span class="lineNum">     179 </span>            :    * @return true if yes it is available, false otherwise</a>
<a name="180"><span class="lineNum">     180 </span>            :    */</a>
<a name="181"><span class="lineNum">     181 </span>            :   template&lt;class Base&gt;</a>
<a name="182"><span class="lineNum">     182 </span>            :   bool isClassAvailable(const std::string &amp; class_name) const</a>
<a name="183"><span class="lineNum">     183 </span>            :   {</a>
<a name="184"><span class="lineNum">     184 </span>            :     std::vector&lt;std::string&gt; available_classes = getAvailableClasses&lt;Base&gt;();</a>
<a name="185"><span class="lineNum">     185 </span>            :     return std::find(</a>
<a name="186"><span class="lineNum">     186 </span>            :       available_classes.begin(), available_classes.end(), class_name) != available_classes.end();</a>
<a name="187"><span class="lineNum">     187 </span>            :   }</a>
<a name="188"><span class="lineNum">     188 </span>            : </a>
<a name="189"><span class="lineNum">     189 </span>            :   /**</a>
<a name="190"><span class="lineNum">     190 </span>            :    * @brief Gets the full-qualified path and name of the library associated with this class loader</a>
<a name="191"><span class="lineNum">     191 </span>            :    */</a>
<a name="192"><span class="lineNum">     192 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="193"><span class="lineNum">     193 </span>            :   const std::string &amp; getLibraryPath() const;</a>
<a name="194"><span class="lineNum">     194 </span>            : </a>
<a name="195"><span class="lineNum">     195 </span>            :   /**</a>
<a name="196"><span class="lineNum">     196 </span>            :    * @brief  Indicates if a library is loaded within the scope of this ClassLoader. Note that the library may already be loaded internally through another ClassLoader, but until loadLibrary() method is called, the ClassLoader cannot create objects from said library. If we want to see if the library has been opened by somebody else, @see isLibraryLoadedByAnyClassloader()</a>
<a name="197"><span class="lineNum">     197 </span>            :    * @param  library_path The path to the library to load</a>
<a name="198"><span class="lineNum">     198 </span>            :    * @return true if library is loaded within this ClassLoader object's scope, otherwise false</a>
<a name="199"><span class="lineNum">     199 </span>            :    */</a>
<a name="200"><span class="lineNum">     200 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="201"><span class="lineNum">     201 </span>            :   bool isLibraryLoaded() const;</a>
<a name="202"><span class="lineNum">     202 </span>            : </a>
<a name="203"><span class="lineNum">     203 </span>            :   /**</a>
<a name="204"><span class="lineNum">     204 </span>            :    * @brief  Indicates if a library is loaded by some entity in the plugin system (another ClassLoader), but not necessarily loaded by this ClassLoader</a>
<a name="205"><span class="lineNum">     205 </span>            :    * @return true if library is loaded within the scope of the plugin system, otherwise false</a>
<a name="206"><span class="lineNum">     206 </span>            :    */</a>
<a name="207"><span class="lineNum">     207 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="208"><span class="lineNum">     208 </span>            :   bool isLibraryLoadedByAnyClassloader() const;</a>
<a name="209"><span class="lineNum">     209 </span>            : </a>
<a name="210"><span class="lineNum">     210 </span>            :   /**</a>
<a name="211"><span class="lineNum">     211 </span>            :    * @brief Indicates if the library is to be loaded/unloaded on demand...meaning that only to load a lib when the first plugin is created and automatically shut it down when last active plugin is destroyed.</a>
<a name="212"><span class="lineNum">     212 </span>            :    */</a>
<a name="213"><span class="lineNum">     213 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="214"><span class="lineNum">     214 </span>            :   bool isOnDemandLoadUnloadEnabled() const;</a>
<a name="215"><span class="lineNum">     215 </span>            : </a>
<a name="216"><span class="lineNum">     216 </span>            :   /**</a>
<a name="217"><span class="lineNum">     217 </span>            :    * @brief  Attempts to load a library on behalf of the ClassLoader. If the library is already opened, this method has no effect. If the library has been already opened by some other entity (i.e. another ClassLoader or global interface), this object is given permissions to access any plugin classes loaded by that other entity. This is</a>
<a name="218"><span class="lineNum">     218 </span>            :    * @param  library_path The path to the library to load</a>
<a name="219"><span class="lineNum">     219 </span>            :    */</a>
<a name="220"><span class="lineNum">     220 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="221"><span class="lineNum">     221 </span>            :   void loadLibrary();</a>
<a name="222"><span class="lineNum">     222 </span>            : </a>
<a name="223"><span class="lineNum">     223 </span>            :   /**</a>
<a name="224"><span class="lineNum">     224 </span>            :    * @brief  Attempts to unload a library loaded within scope of the ClassLoader. If the library is not opened, this method has no effect. If the library is opened by other another ClassLoader, the library will NOT be unloaded internally -- however this ClassLoader will no longer be able to instantiate class_loader bound to that library. If there are plugin objects that exist in memory created by this classloader, a warning message will appear and the library will not be unloaded. If loadLibrary() was called multiple times (e.g. in the case of multiple threads or purposefully in a single thread), the user is responsible for calling unloadLibrary() the same number of times. The library will not be unloaded within the context of this classloader until the number of unload calls matches the number of loads.</a>
<a name="225"><span class="lineNum">     225 </span>            :    * @return The number of times more unloadLibrary() has to be called for it to be unbound from this ClassLoader</a>
<a name="226"><span class="lineNum">     226 </span>            :    */</a>
<a name="227"><span class="lineNum">     227 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="228"><span class="lineNum">     228 </span>            :   int unloadLibrary();</a>
<a name="229"><span class="lineNum">     229 </span>            : </a>
<a name="230"><span class="lineNum">     230 </span>            : private:</a>
<a name="231"><span class="lineNum">     231 </span>            :   /**</a>
<a name="232"><span class="lineNum">     232 </span>            :    * @brief Callback method when a plugin created by this class loader is destroyed</a>
<a name="233"><span class="lineNum">     233 </span>            :    * @param obj - A pointer to the deleted object</a>
<a name="234"><span class="lineNum">     234 </span>            :    */</a>
<a name="235"><span class="lineNum">     235 </span>            :   template&lt;class Base&gt;</a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">          1 :   void onPluginDeletion(Base * obj)</span></a>
<a name="237"><span class="lineNum">     237 </span>            :   {</a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">          1 :     CONSOLE_BRIDGE_logDebug(</span></a>
<a name="239"><span class="lineNum">     239 </span>            :       &quot;class_loader::ClassLoader: Calling onPluginDeletion() for obj ptr = %p.\n&quot;,</a>
<a name="240"><span class="lineNum">     240 </span>            :       reinterpret_cast&lt;void *&gt;(obj));</a>
<a name="241"><span class="lineNum">     241 </span><span class="lineCov">          1 :     if (nullptr == obj) {</span></a>
<a name="242"><span class="lineNum">     242 </span>            :       return;</a>
<a name="243"><span class="lineNum">     243 </span>            :     }</a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">          1 :     std::lock_guard&lt;std::recursive_mutex&gt; lock(plugin_ref_count_mutex_);</span></a>
<a name="245"><span class="lineNum">     245 </span><span class="lineCov">          1 :     delete (obj);</span></a>
<a name="246"><span class="lineNum">     246 </span>            :     assert(plugin_ref_count_ &gt; 0);</a>
<a name="247"><span class="lineNum">     247 </span><span class="lineCov">          1 :     --plugin_ref_count_;</span></a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">          1 :     if (plugin_ref_count_ == 0 &amp;&amp; isOnDemandLoadUnloadEnabled()) {</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineNoCov">          0 :       if (!ClassLoader::hasUnmanagedInstanceBeenCreated()) {</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineNoCov">          0 :         unloadLibraryInternal(false);</span></a>
<a name="251"><span class="lineNum">     251 </span>            :       } else {</a>
<a name="252"><span class="lineNum">     252 </span><span class="lineNoCov">          0 :         CONSOLE_BRIDGE_logWarn(</span></a>
<a name="253"><span class="lineNum">     253 </span>            :           &quot;class_loader::ClassLoader: &quot;</a>
<a name="254"><span class="lineNum">     254 </span>            :           &quot;Cannot unload library %s even though last shared pointer went out of scope. &quot;</a>
<a name="255"><span class="lineNum">     255 </span>            :           &quot;This is because createUnmanagedInstance was used within the scope of this process, &quot;</a>
<a name="256"><span class="lineNum">     256 </span>            :           &quot;perhaps by a different ClassLoader. &quot;</a>
<a name="257"><span class="lineNum">     257 </span>            :           &quot;Library will NOT be closed.&quot;,</a>
<a name="258"><span class="lineNum">     258 </span>            :           getLibraryPath().c_str());</a>
<a name="259"><span class="lineNum">     259 </span>            :       }</a>
<a name="260"><span class="lineNum">     260 </span>            :     }</a>
<a name="261"><span class="lineNum">     261 </span>            :   }</a>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<a name="263"><span class="lineNum">     263 </span>            :   /// Generates an instance of loadable classes (i.e. class_loader).</a>
<a name="264"><span class="lineNum">     264 </span>            :   /**</a>
<a name="265"><span class="lineNum">     265 </span>            :    * It is not necessary for the user to call loadLibrary() as it will be</a>
<a name="266"><span class="lineNum">     266 </span>            :    * invoked automatically if the library is not yet loaded (which typically</a>
<a name="267"><span class="lineNum">     267 </span>            :    * happens when in &quot;On Demand Load/Unload&quot; mode).</a>
<a name="268"><span class="lineNum">     268 </span>            :    *</a>
<a name="269"><span class="lineNum">     269 </span>            :    * @param derived_class_name</a>
<a name="270"><span class="lineNum">     270 </span>            :    *   The name of the class we want to create (@see getAvailableClasses()).</a>
<a name="271"><span class="lineNum">     271 </span>            :    * @param managed</a>
<a name="272"><span class="lineNum">     272 </span>            :    *   If true, the returned pointer is assumed to be wrapped in a smart</a>
<a name="273"><span class="lineNum">     273 </span>            :    *   pointer by the caller.</a>
<a name="274"><span class="lineNum">     274 </span>            :    * @return A Base* to newly created plugin object.</a>
<a name="275"><span class="lineNum">     275 </span>            :    */</a>
<a name="276"><span class="lineNum">     276 </span>            :   template&lt;class Base&gt;</a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">          1 :   Base * createRawInstance(const std::string &amp; derived_class_name, bool managed)</span></a>
<a name="278"><span class="lineNum">     278 </span>            :   {</a>
<a name="279"><span class="lineNum">     279 </span><span class="lineCov">          1 :     if (!managed) {</span></a>
<a name="280"><span class="lineNum">     280 </span><span class="lineNoCov">          0 :       this-&gt;setUnmanagedInstanceBeenCreated(true);</span></a>
<a name="281"><span class="lineNum">     281 </span>            :     }</a>
<a name="282"><span class="lineNum">     282 </span>            : </a>
<a name="283"><span class="lineNum">     283 </span>            :     if (</a>
<a name="284"><span class="lineNum">     284 </span><span class="lineCov">          1 :       managed &amp;&amp;</span></a>
<a name="285"><span class="lineNum">     285 </span><span class="lineCov">          1 :       ClassLoader::hasUnmanagedInstanceBeenCreated() &amp;&amp;</span></a>
<a name="286"><span class="lineNum">     286 </span><span class="lineNoCov">          0 :       isOnDemandLoadUnloadEnabled())</span></a>
<a name="287"><span class="lineNum">     287 </span>            :     {</a>
<a name="288"><span class="lineNum">     288 </span><span class="lineNoCov">          0 :       CONSOLE_BRIDGE_logInform(</span></a>
<a name="289"><span class="lineNum">     289 </span>            :         &quot;%s&quot;,</a>
<a name="290"><span class="lineNum">     290 </span>            :         &quot;class_loader::ClassLoader: &quot;</a>
<a name="291"><span class="lineNum">     291 </span>            :         &quot;An attempt is being made to create a managed plugin instance (i.e. boost::shared_ptr), &quot;</a>
<a name="292"><span class="lineNum">     292 </span>            :         &quot;however an unmanaged instance was created within this process address space. &quot;</a>
<a name="293"><span class="lineNum">     293 </span>            :         &quot;This means libraries for the managed instances will not be shutdown automatically on &quot;</a>
<a name="294"><span class="lineNum">     294 </span>            :         &quot;final plugin destruction if on demand (lazy) loading/unloading mode is used.&quot;</a>
<a name="295"><span class="lineNum">     295 </span>            :       );</a>
<a name="296"><span class="lineNum">     296 </span>            :     }</a>
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">          1 :     if (!isLibraryLoaded()) {</span></a>
<a name="298"><span class="lineNum">     298 </span><span class="lineNoCov">          0 :       loadLibrary();</span></a>
<a name="299"><span class="lineNum">     299 </span>            :     }</a>
<a name="300"><span class="lineNum">     300 </span>            : </a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">          1 :     Base * obj = class_loader::impl::createInstance&lt;Base&gt;(derived_class_name, this);</span></a>
<a name="302"><span class="lineNum">     302 </span>            :     assert(obj != NULL);  // Unreachable assertion if createInstance() throws on failure.</a>
<a name="303"><span class="lineNum">     303 </span>            : </a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">          1 :     if (managed) {</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">          1 :       std::lock_guard&lt;std::recursive_mutex&gt; lock(plugin_ref_count_mutex_);</span></a>
<a name="306"><span class="lineNum">     306 </span><span class="lineCov">          1 :       ++plugin_ref_count_;</span></a>
<a name="307"><span class="lineNum">     307 </span>            :     }</a>
<a name="308"><span class="lineNum">     308 </span>            : </a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">          1 :     return obj;</span></a>
<a name="310"><span class="lineNum">     310 </span>            :   }</a>
<a name="311"><span class="lineNum">     311 </span>            : </a>
<a name="312"><span class="lineNum">     312 </span>            :   /**</a>
<a name="313"><span class="lineNum">     313 </span>            :    * @brief Getter for if an unmanaged (i.e. unsafe) instance has been created flag</a>
<a name="314"><span class="lineNum">     314 </span>            :    */</a>
<a name="315"><span class="lineNum">     315 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="316"><span class="lineNum">     316 </span>            :   static bool hasUnmanagedInstanceBeenCreated();</a>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="319"><span class="lineNum">     319 </span>            :   static void setUnmanagedInstanceBeenCreated(bool state);</a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span>            :   /**</a>
<a name="322"><span class="lineNum">     322 </span>            :    * @brief As the library may be unloaded in &quot;on-demand load/unload&quot; mode, unload maybe called from createInstance(). The problem is that createInstance() locks the plugin_ref_count as does unloadLibrary(). This method is the implementation of unloadLibrary but with a parameter to decide if plugin_ref_mutex_ should be locked</a>
<a name="323"><span class="lineNum">     323 </span>            :    * @param lock_plugin_ref_count - Set to true if plugin_ref_count_mutex_ should be locked, else false</a>
<a name="324"><span class="lineNum">     324 </span>            :    * @return The number of times unloadLibraryInternal has to be called again for it to be unbound from this ClassLoader</a>
<a name="325"><span class="lineNum">     325 </span>            :    */</a>
<a name="326"><span class="lineNum">     326 </span>            :   CLASS_LOADER_PUBLIC</a>
<a name="327"><span class="lineNum">     327 </span>            :   int unloadLibraryInternal(bool lock_plugin_ref_count);</a>
<a name="328"><span class="lineNum">     328 </span>            : </a>
<a name="329"><span class="lineNum">     329 </span>            : private:</a>
<a name="330"><span class="lineNum">     330 </span>            :   bool ondemand_load_unload_;</a>
<a name="331"><span class="lineNum">     331 </span>            :   std::string library_path_;</a>
<a name="332"><span class="lineNum">     332 </span>            :   int load_ref_count_;</a>
<a name="333"><span class="lineNum">     333 </span>            :   std::recursive_mutex load_ref_count_mutex_;</a>
<a name="334"><span class="lineNum">     334 </span>            :   int plugin_ref_count_;</a>
<a name="335"><span class="lineNum">     335 </span>            :   std::recursive_mutex plugin_ref_count_mutex_;</a>
<a name="336"><span class="lineNum">     336 </span>            :   static bool has_unmananged_instance_been_created_;</a>
<a name="337"><span class="lineNum">     337 </span>            : };</a>
<a name="338"><span class="lineNum">     338 </span>            : </a>
<a name="339"><span class="lineNum">     339 </span>            : }  // namespace class_loader</a>
<a name="340"><span class="lineNum">     340 </span>            : </a>
<a name="341"><span class="lineNum">     341 </span>            : </a>
<a name="342"><span class="lineNum">     342 </span>            : #endif  // CLASS_LOADER__CLASS_LOADER_HPP_</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
